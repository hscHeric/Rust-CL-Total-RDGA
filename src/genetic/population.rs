use kambo_graph::graphs::simple::UndirectedGraph;

use super::{Chromosome, Crossover, Heuristic, Selection};

/// Represents a population of chromosomes for evolutionary algorithms.
///
/// The population is responsible for maintaining a collection of chromosomes,
/// managing their initialization through heuristics, and calculating aggregate
/// metrics such as average fitness.
///
/// # Fields
/// - `chromosomes: Vec<Chromosome>`: A vector containing the chromosomes in the population.
/// - `size: usize`: The maximum size of the population.
#[derive(Clone)]
pub struct Population {
    chromosomes: Vec<Chromosome>,
    size: usize,
}

impl Population {
    /// Creates a new population of chromosomes using the provided heuristics and graph.
    ///
    /// This function generates chromosomes by applying the heuristics in sequence. If the
    /// population size exceeds the number of heuristics, the last heuristic is used to
    /// generate the remaining chromosomes.
    ///
    /// # Parameters
    /// - `size: usize`: The number of chromosomes to generate for the population.
    /// - `heuristics: Vec<Heuristic>`:
    ///   A vector of heuristic functions used to generate chromosomes.
    ///   Each heuristic is a function of the form `fn(&UnGraph<u32, ()>) -> Chromosome`.
    /// - `graph: &UnGraph<u32, ()>`:
    ///   An undirected graph that represents the problem structure.
    ///
    /// # Panics
    /// - If the `heuristics` vector is empty.
    ///   - Panic message: `"At least one heuristic must be provided."`
    ///
    /// # Returns
    /// - A new instance of `Population` with chromosomes generated by the heuristics.
    ///
    /// # Notes
    /// - Chromosomes are adjusted using their `fix` method to ensure they satisfy
    ///   problem-specific constraints.
    #[inline]
    #[must_use]
    pub fn new(size: usize, heuristics: &[Heuristic], graph: &UndirectedGraph<u32>) -> Self {
        assert!(
            !heuristics.is_empty(),
            "At least one heuristic must be provided."
        );
        let mut chromosomes = Vec::with_capacity(size);

        for heuristic in heuristics {
            if chromosomes.len() < size {
                let chromosome = heuristic(graph);
                chromosomes.push(chromosome);
            }
        }

        let last_heuristic = *heuristics.last().unwrap();
        while chromosomes.len() < size {
            let chromosome = last_heuristic(graph);
            chromosomes.push(chromosome);
        }

        Self { chromosomes, size }
    }

    /// Returns the size of the population.
    ///
    /// # Returns
    /// - A `usize` value representing the number of chromosomes in the population.
    #[inline]
    #[must_use]
    pub fn size(&self) -> usize {
        self.size
    }

    /// Returns a reference to the chromosomes in the population.
    ///
    /// # Returns
    /// - A slice of `Chromosome` representing the chromosomes in the population.
    #[inline]
    #[must_use]
    pub fn chromosomes(&self) -> &[Chromosome] {
        &self.chromosomes
    }

    /// Evolves the population by applying selection and crossover operations.
    ///
    /// The method iteratively selects parent chromosomes using the provided selection strategy,
    /// applies the crossover operator to generate offspring, and replaces the population with
    /// the newly generated chromosomes.
    ///
    /// # Parameters
    /// - `selector: &S`: A reference to a selection strategy that implements the `Selection` trait.
    ///   The selector is used to choose parent chromosomes from the current population.
    /// - `crossover: &C`: A reference to a crossover strategy that implements the `Crossover` trait.
    ///   The crossover operator generates offspring chromosomes from selected parent chromosomes.
    /// - `graph: &UnGraph<u32, ()>`: A reference to the underlying graph structure, used to validate
    ///   or influence the crossover operation.
    ///
    /// # Behavior
    /// 1. A new vector of chromosomes is pre-allocated with the same size as the current population.
    /// 2. While the number of new chromosomes is less than the population size:
    ///    - Two parent chromosomes are selected using the provided `selector`.
    ///    - The `crossover` operator is applied to generate two offspring chromosomes.
    ///    - The offspring chromosomes are added to the new population.
    /// 3. Once the new population is complete, the chromosomes are added back to the population.
    #[inline]
    pub fn envolve<S: Selection, C: Crossover>(
        &mut self,
        selector: &S,
        crossover: &C,
        graph: &UndirectedGraph<u32>,
    ) {
        let mut new_chromosomes: Vec<Chromosome> = Vec::with_capacity(self.size);

        while new_chromosomes.len() < self.size() {
            let parent1 = selector.select(self);
            let parent2 = selector.select(self);

            let (child1, child2) = crossover.crossover(parent1, parent2, graph);
            new_chromosomes.push(child1);
            new_chromosomes.push(child2);
        }

        self.chromosomes = new_chromosomes;
    }

    /// Returns a reference to the chromosome with the best fitness (lowest value).
    #[must_use]
    pub fn best_chromosome(&self) -> Option<&Chromosome> {
        self.chromosomes()
            .iter()
            .min_by_key(|chromosome| chromosome.fitness())
    }
}
